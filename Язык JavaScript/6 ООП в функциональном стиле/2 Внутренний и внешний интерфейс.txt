//////////////////////////////////////////////////
КРАТКО

Свойства (поля)
this.p // публичное свойство (поле)
p // приватное свойство (поле)

Методы
this.run = function() {} // публичный метод
function run() {} // приватный метод

Доступ к объекту из внутреннего метода
++ Указание контекста ++
getBoilTime.call(this);
++ Привязка через bind ++
var getBoilTime = function() {return this.p;}.bind(this);
++ Сохрание this в замыкании ++
var self = this;
function getBoilTime() { return self.p;}

//////////////////////////////////////////////////
ВНУТРЕННИЙ И ВНЕШНИЙ ИНТЕРФЕЙС

Один из важнейших принципов ООП – отделение внутреннего интерфейса от внешнего.
Внутренний интерфейс – это свойства и методы, доступ к которым может быть осуществлен только из других методов объекта, их также называют «приватными» (есть и другие термины, встретим их далее).

Внешний интерфейс – это свойства и методы, доступные снаружи объекта, их называют «публичными».


/////////////////////////////////////////////////
ПУБЛИЧНОЕ И ПРИВАТНОЕ СВОЙСТВО

this.p - публичный
p - приватный

function CoffeeMachine(power) {
  this.waterAmount = 0; // количество воды в кофеварке
  alert( 'Создана кофеварка мощностью: ' + power + ' ватт' );
}

// создать кофеварку
var coffeeMachine = new CoffeeMachine(100);

// залить воды
coffeeMachine.waterAmount = 200;

Локальные переменные, включая параметры конструктора, можно считать приватными свойствами.

Свойства, записанные в this, можно считать публичными.

/////////////////////////////////////////////////
ПУБЛИЧНЫЙ И ПРИВАТНЫЙ МЕТОД

function CoffeeMachine(power) {
	// публичный метод
	this.run = function() { return getPower(); };
	// приватный метод
	function getPower() {return power;}
}

/////////////////////////////////////////////////
КОНСТАНТА

var WATER_HEAT_CAPACITY = 4200;

/////////////////////////////////////////////////
ДОСТУП К ОБЪЕКТУ ИЗ ВНУТРЕННЕГО МЕТОДА

++ Указание контекста ++

getBoilTime.call(this) // указание контекста


function CoffeeMachine(power) {

  this.waterAmount = 0;

  function getBoilTime() {
      return this.waterAmount; // ошибка!
    }

  function onReady() {
    alert( 'Кофе готов!' );
  }

  this.run = function() {
    setTimeout(onReady, getBoilTime());
  };
}


this равен undefined

  this.run = function() {
    setTimeout(onReady, getBoilTime.call(this)); // верно
  };


getBoilTime.call(this) // указание контекста


++ Привязка через bind ++

  var getBoilTime = function() {
    return this.waterAmount * WATER_HEAT_CAPACITY * 80 / power;
  }.bind(this);


++ Сохрание this в замыкании ++

var self = this;

function getBoilTime() {
	return self.waterAmount * WATER_HEAT_CAPACITY * 80 / power;
}

Теперь getBoilTime получает self из замыкания.

Чтобы это работало, мы не должны изменять self, а все приватные методы, которые хотят иметь доступ к текущему объекту, должны использовать внутри себя self вместо this.
/////////////////////////////////////////////////
