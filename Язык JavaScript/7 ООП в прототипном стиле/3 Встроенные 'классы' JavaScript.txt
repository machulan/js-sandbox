КРАТКО

/////////////////////////////////////////////////////////////////
ОТКУДА МЕТОДЫ У {}?

var obj = {};
alert( obj ); // "[object Object]" ?

ОБЪЕКТ ПУСТОЙ. Где находится метод, генерирующий вывод?

/////////////////////////////////////////////////////////////////
Object.prototype

1 obj = {} - краткая форма для obj = new Object
Object - встроенная функция-конструктор для объектов.
2 По определению, при создании нового объекта с помощью new в его __proto__ записывается объект, содержащийся в Object.prototype.
	1) prototype - "статическое" свойство функции Object, то есть, одно единственное для всех новых объектов, создаваемых конструктором Object;
	2) obj и Object.prototype - аналоги rabbit и animal (rabbit.__proto__ = animal);
3 В дальнейшем при обращении к obj.toString() – функция будет взята из Object.prototype.

ТАКИМ ОБРАЗОМ:

var obj = {};

// метод берётся из прототипа?
alert( obj.toString == Object.prototype.toString ); // true, да

// проверим, правда ли что __proto__ это Object.prototype?
alert( obj.__proto__ == Object.prototype ); // true

// А есть ли __proto__ у Object.prototype?
alert( obj.__proto__.__proto__ ); // null, нет

/////////////////////////////////////////////////////////////////
ВСТРОЕННЫЕ "КЛАССЫ" В JavaScript

Точно такой же подход используется в массивах Array, функциях Function и других объектах. Встроенные методы для них находятся в Array.prototype, Function.prototype и т.п.

"Все объекты наследуют от Object", а если более точно, то от Object.prototype.

КЛАСС = ФУНКЦИЯ-КОНСТРУКТОР F + ее "статическое" свойство F.prototype.
Этот способ объявления классов - ПРОТОТИПНЫЙ СТИЛЬ ООП.

/////////////////////////////////////////////////////////////////
ВЫЗОВ МЕТОДОВ ЧЕРЕЗ call И apply ИЗ ПРОТОТИПА

ПРИМЕР (для arguments):
[].join.call(arguments, " - ") // с созданием нового объекта
Array.prototype.join.call(arguments, " - ") // использование напрямую

/////////////////////////////////////////////////////////////////
ПРИМИТИВЫ

Примитивы не являются объектами.
Но методы берут из прототипов: Number.prototype, Boolean.prototype, String.prototype.

Конструкторы String/Number/Boolean – только для внутреннего использования.
alert( typeof 1 ); // "number"
alert( typeof new Number(1) ); // "object" ?!?
var zero = new Number(0);
if (zero) { // объект - true, так что alert выполнится
  alert( "число ноль -- true?!?" );
}

Значения null и undefined не имеют свойств.

/////////////////////////////////////////////////////////////////
ИЗМЕНЕНИЕ ВСТРОЕННЫХ ПРОТОТИПОВ

Встроенные прототипы можно изменять.

String.prototype.repeat = function(times) {
	return new Array(times + 1).join(this);
}
alert("Га ".repeat(3));

