КРАТКО

Значение this устанавливается в зависимости от того, как вызвана функция:
1 При вызове функции как метода:
obj.func(...)    // this = obj
obj["func"](...)
2 При обычном вызове:
func(...) // this = window (ES3) /undefined (ES5)
3 В new:
new func() // this = {} (новый объект)
4 Явное указание:
func.apply(context, args) // this = context (явная передача)
func.call(context, arg1, arg2, ...)


////////////////////////////////////////////////////////////////////////
МЕТОД call

func.call(context, arg1, arg2, ...)

Вызов func.call(context, a, b...) – то же, что обычный вызов func(a, b...), но с явно указанным this(=context).

////////////////////////////////////////////////////////////////////////
"ОДАЛЖИВАНИЕ МЕТОДА"

Используем эту технику для упрощения манипуляций с arguments.

function printArgs() {
  arguments.join = [].join; // одолжили метод (1)
  var argStr = arguments.join(':'); // (2)
  alert( argStr ); // сработает и выведет 1:2:3
}
ИЛИ
function printArgs() {
  var join = [].join; // скопируем ссылку на функцию в переменную
  // вызовем join с this=arguments,
  // этот вызов эквивалентен arguments.join(':') из примера выше
  var argStr = join.call(arguments, ':');
  alert( argStr ); // сработает и выведет 1:2:3
}

printArgs(1, 2, 3);

////////////////////////////////////////////////////////////////////////
Ещё пример: [].slice.call(arguments) ++ ЧИТЕРСТВО ++

Очень простой способ сделать из arguments настоящий массив.
 
function printArgs() {
  // вызов arr.slice() скопирует все элементы из this в новый массив
  var args = [].slice.call(arguments);
  alert( args.join(', ') ); // args - полноценный массив из аргументов
}

////////////////////////////////////////////////////////////////////////
МЕТОД apply

Вызов функции при помощи func.apply работает аналогично func.call, но принимает массив аргументов вместо списка.

func.call(context, arg1, arg2);
// идентичен вызову
func.apply(context, [arg1, arg2]);

//////////////////////////////////////////////////////////////////////////
MAX НА МАССИВЕ

Math.max.apply(null, array);

СТРОГОЕ СООТВЕТСТВИЕ Math.max(1,2,3) ЕСТЬ Math.max.apply(Math, [1,2,3])

//////////////////////////////////////////////////////////////////////////
ВЫЗОВ call/apply С null ИЛИ undefined

Современный стандарт: this «как есть».
Старый стандарт: this == window.