КРАТКО

1 Методы встроенных объектов хранятся в их прототипах.

2 Встроенные прототипы можно расширить или поменять.

3 Добавление методов в Object.prototype, если оно не сопровождается Object.defineProperty с установкой enumerable (IE9+), "сломает" циклы for..in, поэтому стараются в этот прототип методы не добавлять.

Другие прототипы изменять менее опасно, но все же не рекомендуется во избежание конфликтов.

Отдельно стоит изменение с целью добавления современных методов в старые браузеры, таких как Object.create, Object.keys, Function.prototype.bind и т.п. Это допустимо и как раз делается es5-shim.

/////////////////////////////////////////////////////////////////
ОТКУДА МЕТОДЫ У {}?

var obj = {};
alert( obj ); // "[object Object]" ?

ОБЪЕКТ ПУСТОЙ. Где находится метод, генерирующий вывод?

/////////////////////////////////////////////////////////////////
Object.prototype

1 obj = {} - краткая форма для obj = new Object
Object - встроенная функция-конструктор для объектов.
2 По определению, при создании нового объекта с помощью new в его __proto__ записывается объект, содержащийся в Object.prototype.
	1) prototype - "статическое" свойство функции Object, то есть, одно единственное для всех новых объектов, создаваемых конструктором Object;
	2) obj и Object.prototype - аналоги rabbit и animal (rabbit.__proto__ = animal);
3 В дальнейшем при обращении к obj.toString() – функция будет взята из Object.prototype.

ТАКИМ ОБРАЗОМ:

var obj = {};

// метод берётся из прототипа?
alert( obj.toString == Object.prototype.toString ); // true, да

// проверим, правда ли что __proto__ это Object.prototype?
alert( obj.__proto__ == Object.prototype ); // true

// А есть ли __proto__ у Object.prototype?
alert( obj.__proto__.__proto__ ); // null, нет

/////////////////////////////////////////////////////////////////
ВСТРОЕННЫЕ "КЛАССЫ" В JavaScript

Точно такой же подход используется в массивах Array, функциях Function и других объектах. Встроенные методы для них находятся в Array.prototype, Function.prototype и т.п.

"Все объекты наследуют от Object", а если более точно, то от Object.prototype.

КЛАСС = ФУНКЦИЯ-КОНСТРУКТОР F + ее "статическое" свойство F.prototype.
Этот способ объявления классов - ПРОТОТИПНЫЙ СТИЛЬ ООП.

/////////////////////////////////////////////////////////////////
ВЫЗОВ МЕТОДОВ ЧЕРЕЗ call И apply ИЗ ПРОТОТИПА

ПРИМЕР (для arguments):
[].join.call(arguments, " - ") // с созданием нового объекта
Array.prototype.join.call(arguments, " - ") // использование напрямую

/////////////////////////////////////////////////////////////////
ПРИМИТИВЫ

Примитивы не являются объектами.
Но методы берут из прототипов: Number.prototype, Boolean.prototype, String.prototype.

Конструкторы String/Number/Boolean – только для внутреннего использования.
alert( typeof 1 ); // "number"
alert( typeof new Number(1) ); // "object" ?!?
var zero = new Number(0);
if (zero) { // объект - true, так что alert выполнится
  alert( "число ноль -- true?!?" );
}

Значения null и undefined не имеют свойств.

/////////////////////////////////////////////////////////////////
ИЗМЕНЕНИЕ ВСТРОЕННЫХ ПРОТОТИПОВ

Встроенные прототипы можно изменять.

ПРИМЕР 1:
String.prototype.repeat = function(times) {
	return new Array(times + 1).join(this);
}
alert("Га ".repeat(3)); // "Га Га Га "

ПРИМЕР 2:
Object.prototype.each = function(f) {
  for (var prop in this) {
    var value = this[prop];
    f.call(value, prop, value); // вызовет f(prop, value), this=value
  }
}

// Попробуем! (внимание, пока что это работает неверно!)
var user = {
  name: 'Вася',
  age: 25
};

user.each(function(prop, val) {
  alert( prop ); // name -> age -> (!) each
});

НО for .. in В ТАКОМ ОБЪЕКТЕ БУДЕТ РАБОТАТЬ НЕВЕРНО, ТАК КАК НАЙДЕТ И САМ  МЕТОД each.

РЕШЕНИЕ:
1 пропускать свойства из прототипа:
	if (!this.hasOwnProperty(prop)) continue;
2 использовать дескриптор свойства и флаг enumerable
	Object.defineProperty(Object.prototype, 'each', {
 		enumerable: false
	});
3 не добавлять свойства в Object.prototype

Допустимо изменение прототипа встроенных объектов, которое добавляет поддержку метода из современных стандартов в те браузеры, где её пока нет.
