КРАТКО

1 Функции в JavaScript никак не привязаны к своему контексту this.
Функция сама по себе не запоминает контекст выполнения.

2 Чтобы гарантировать правильный контекст для вызова obj.func(), нужно использовать функцию-обёртку, задать её через анонимную функцию:
setTimeout(function() {
  obj.func();
})

3 Либо использовать bind:
setTimeout(obj.func.bind(obj));

4 Вызов bind часто используют для привязки функции к контексту, чтобы затем присвоить её в обычную переменную и вызывать уже без явного указания объекта.

5 Вызов bind также позволяет фиксировать первые аргументы функции («каррировать» её), и таким образом из общей функции получить её «частные» варианты – чтобы использовать их многократно без повтора одних и тех же аргументов каждый раз.


//////////////////////////////////////////////////////////////////////
ПРИМЕР ПОТЕРИ КОНТЕКСТА

var user = {
  firstName: "Вася",
  sayHi: function() {
    alert( this.firstName );
  }
};

setTimeout(user.sayHi, 1000); // undefined (не Вася!)

Строка выше - аналог двух следующих строк:
var f = user.sayHi;
setTimeout(f, 1000); // контекст user потеряли

//////////////////////////////////////////////////////////////////////
РЕШЕНИЕ 1 : СДЕЛАТЬ ОБЕРТКУ

setTimeout(function() {
  user.sayHi(); // Вася
}, 1000);

Но тут же появляется и уязвимое место в структуре кода!
А что, если до срабатывания setTimeout (ведь есть целая секунда) в переменную user будет записано другое значение? 

//////////////////////////////////////////////////////////////////////
РЕШЕНИЕ 2 : bind ДЛЯ ПРИВЯЗКИ КОНТЕКСТА

// Функция для привязки контекста
function bind(func, context) {
  return function() { // (*)
    return func.apply(context, arguments);
  };
}

function f() {
  alert( this );
}

var g = bind(f, "Context");
g(); // Context

Иными словами, в результате вызова bind(func, context) мы получаем «функцию-обёртку», которая прозрачно передаёт вызов в func, с теми же аргументами, но фиксированным контекстом context.

var user = {
  firstName: "Вася",
  sayHi: function() {
    alert( this.firstName );
  }
};
setTimeout(bind(user.sayHi, user), 1000); // Все в порядке

//////////////////////////////////////////////////////////////////
РЕШЕНИЕ 3 : ВСТРОЕННЫЙ МЕТОД bind

var wrapper = func.bind(context[, arg1, arg2...])
func - произвольная функция
context - контекст, который привязывается к func
arg1, arg2, … - если указаны аргументы arg1, arg2... – они будут прибавлены к каждому вызову новой функции, причем встанут перед теми, которые указаны при вызове.

function f(a, b) {
  alert( this );
  alert( a + b );
}
// вместо
// var g = bind(f, "Context");
var g = f.bind("Context");
g(1, 2); // Context, затем 3

//////////////////////////////////////////////////////////////////
bind НЕ ПОХОЖ на call/apply

Методы call/apply вызывают функцию с заданным контекстом и аргументами.

А bind не вызывает функцию. Он только возвращает «обёртку», которую мы можем вызвать позже, и которая передаст вызов в исходную функцию, с привязанным контекстом.

//////////////////////////////////////////////////////////////////
ПРИВЯЗАТЬ ВСЕ : bindAll  

for (var prop in user) {
  if (typeof user[prop] == 'function') {
    user[prop] = user[prop].bind(user);
  }
}

В некоторых JS-фреймворках есть даже встроенные функции для этого, например _.bindAll(obj).

//////////////////////////////////////////////////////////////////
КАРРИНГ

function mul(a, b) {
  return a * b;
};

// double умножает только на два
var double = mul.bind(null, 2); // контекст фиксируем null, он не используется

alert( double(3) ); // = mul(2, 3) = 6

Говорят, что double является «частичной функцией» (partial function) от mul.

//////////////////////////////////////////////////////////////////
ФУНКЦИЯ ask ДЛЯ ЗАДАЧ

function ask(question, answer, ok, fail) {
  var result = prompt(question, '');
  if (result.toLowerCase() == answer.toLowerCase()) ok();
  else fail();
}

Её назначение – задать вопрос question и, если ответ совпадёт с answer, то запустить функцию ok(), а иначе – функцию fail().

Несмотря на внешнюю простоту, функции такого вида активно используются в реальных проектах.